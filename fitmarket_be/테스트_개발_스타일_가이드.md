# 테스트 개발 스타일 가이드

Spring Boot TDD 프로젝트의 테스트 작성 규칙과 패턴을 정리한 문서입니다.

## 1. 테스트 패키지 구조

### 1.1 기본 디렉토리 구조
```
src/test/java/test/commerce/
├── api/                          # API 테스트
│   ├── CommerceApiTest.java     # 커스텀 테스트 어노테이션
│   ├── TestFixture.java          # 테스트 픽스처
│   ├── TestFixtureConfiguration.java
│   ├── seller/                   # 판매자 관련 API
│   │   ├── signup/
│   │   │   └── POST_specs.java  # POST /seller/signUp 테스트
│   │   ├── issuetoken/
│   │   │   └── POST_specs.java
│   │   ├── me/
│   │   │   └── GET_specs.java
│   │   └── products/
│   │       ├── POST_specs.java
│   │       ├── GET_specs.java
│   │       └── id/
│   │           └── GET_specs.java
│   └── shopper/                  # 구매자 관련 API
│       ├── signup/
│       │   └── POST_specs.java
│       ├── issuetoken/
│       │   └── POST_specs.java
│       └── products/
│           └── GET_specs.java
├── TestDataSource.java           # 테스트 데이터 소스
├── *Generator.java               # 테스트 데이터 생성기
└── *Assertions.java              # 커스텀 검증 로직
```

### 1.2 패키지 구조 원칙

1. **API 경로를 반영한 구조화**
   - API 엔드포인트 경로를 그대로 패키지 구조로 매핑
   - 예: `/seller/signUp` → `test.commerce.api.seller.signup`

2. **리소스별 그룹화**
   - 각 리소스(seller, shopper, products 등)별로 디렉토리 분리
   - 하위 리소스는 중첩 디렉토리로 표현

3. **테스트 유틸리티는 최상위에 배치**
   - Generator, Assertions, DataSource는 `test.commerce` 패키지에 위치
   - 공통 테스트 설정은 `test.commerce.api` 패키지에 위치

## 2. 테스트 파일 네이밍 규칙

### 2.1 테스트 클래스명

**형식**: `{HTTP_METHOD}_specs.java`

**예시**:
- `POST_specs.java` - POST 요청 테스트
- `GET_specs.java` - GET 요청 테스트
- `PUT_specs.java` - PUT 요청 테스트 (필요시)
- `DELETE_specs.java` - DELETE 요청 테스트 (필요시)

**특징**:
- HTTP 메서드를 대문자로 표기
- 클래스명은 `_specs` 접미사 사용
- 하나의 엔드포인트당 하나의 HTTP 메서드 테스트 파일

### 2.2 테스트 메서드명

**형식**: 한글로 작성된 명확한 시나리오 설명

**예시**:
```java
void 올바르게_요청하면_204_No_Content_상태코드를_반환한다()
void email_속성이_지정되지_않으면_400_Bad_Request_상태코드를_반환한다()
void 비밀번호를_올바르게_암호화한다()
void 상품_목록을_등록_시점_역순으로_정렬한다()
```

**작성 원칙**:
- 한글 사용으로 가독성 극대화
- 단어 구분은 언더스코어(`_`) 사용
- "무엇을 테스트하는지" 명확하게 기술
- 예상 결과를 포함하여 작성

### 2.3 헬퍼 클래스 네이밍

**Generator 클래스**:
- 형식: `{Domain}Generator.java`
- 예시: `EmailGenerator.java`, `PasswordGenerator.java`, `UsernameGenerator.java`
- 역할: 테스트 데이터 생성

**Assertions 클래스**:
- 형식: `{Domain}Assertions.java`
- 예시: `ProductAssertions.java`, `JwtAssertions.java`
- 역할: 커스텀 검증 로직 제공

**DataSource 클래스**:
- 형식: `TestDataSource.java`
- 역할: Parameterized 테스트용 데이터 제공

## 3. 테스트 시나리오 작성 패턴

### 3.1 기본 테스트 구조

**Arrange-Act-Assert 패턴 엄격히 준수**:

```java
@Test
void 올바르게_요청하면_204_No_Content_상태코드를_반환한다(
    @Autowired TestRestTemplate client
) {
    // Arrange - 테스트 데이터 준비
    var command = new CreateSellerCommand(
        generateEmail(),
        generateUsername(),
        "password",
        generateEmail()
    );

    // Act - 실제 동작 수행
    ResponseEntity<Void> response = client.postForEntity(
        "/seller/signUp",
        command,
        Void.class
    );

    // Assert - 결과 검증
    assertThat(response.getStatusCode().value()).isEqualTo(204);
}
```

**특징**:
- 주석으로 각 단계를 명확히 구분
- 한 테스트에서 한 가지만 검증
- Given-When-Then 대신 Arrange-Act-Assert 용어 사용

### 3.2 Parameterized 테스트

**@ValueSource 사용 예시**:
```java
@ParameterizedTest
@ValueSource(strings = {
    "invalid-email",
    "invalid-email@",
    "invalid-email@test",
    "invalid-email@test.",
    "invalid-email@.com"
})
void email_속성이_올바른_형식을_따르지_않으면_400_Bad_Request_상태코드를_반환한다(
    String email,
    @Autowired TestRestTemplate client
) {
    // Arrange
    var command = new CreateSellerCommand(
        email,
        generateUsername(),
        "password",
        generateEmail()
    );

    // Act
    ResponseEntity<Void> response = client.postForEntity(
        "/seller/signUp",
        command,
        Void.class
    );

    // Assert
    assertThat(response.getStatusCode().value()).isEqualTo(400);
}
```

**@MethodSource 사용 예시**:
```java
@ParameterizedTest
@MethodSource("test.commerce.TestDataSource#invalidPasswords")
void password_속성이_올바른_형식을_따르지_않으면_400_Bad_Request_상태코드를_반환한다(
    String password,
    @Autowired TestRestTemplate client
) {
    // ... 테스트 로직
}
```

**Parameterized 테스트 작성 원칙**:
- 같은 로직을 다른 입력값으로 반복 테스트할 때 사용
- 경계값 테스트, 유효성 검증 테스트에 적극 활용
- `@ValueSource`는 간단한 값, `@MethodSource`는 복잡한 데이터셋

### 3.3 테스트 시나리오 범위

**API 엔드포인트별 테스트 항목**:

1. **성공 케이스**
   - 올바른 요청에 대한 정상 응답 검증
   - 예: `올바르게_요청하면_204_No_Content_상태코드를_반환한다`

2. **유효성 검증**
   - 필수 속성 누락
   - 속성 형식 검증 (이메일, URL 등)
   - 길이/범위 제약 검증
   - 예: `email_속성이_지정되지_않으면_400_Bad_Request_상태코드를_반환한다`

3. **비즈니스 로직 검증**
   - 중복 검사
   - 권한 검증
   - 정렬 순서 검증
   - 예: `email_속성에_이미_존재하는_이메일_주소가_지정되면_400_Bad_Request_상태코드를_반환한다`

4. **데이터 무결성**
   - 저장된 데이터 검증
   - 암호화/해싱 검증
   - 예: `비밀번호를_올바르게_암호화한다`

## 4. 테스트 픽스처 패턴

### 4.1 TestFixture 사용

**TestFixture 정의**:
```java
public record TestFixture(
    TestRestTemplate client,
    ProductRepository productRepository
) {
    // 테스트 헬퍼 메서드들
}
```

**주입 방법**:
```java
@Test
void 테스트_시나리오(@Autowired TestFixture fixture) {
    // fixture를 통해 테스트 수행
}
```

**주요 메서드 패턴**:
```java
// 사용자 생성
void createShopper(String email, String username, String password)
void createSeller(String email, String username, String password, String contactEmail)

// 토큰 발행
String issueShopperToken(String email, String password)
String issueSellerToken(String email, String password)

// 복합 작업 (생성 + 토큰 발행 + 기본 사용자 설정)
void createShopperThenSetAsDefaultUser()
void createSellerThenSetAsDefaultUser()

// 테스트 데이터 생성
UUID registerProduct()
List<UUID> registerProducts(int count)

// 정리 작업
void deleteAllProducts()
```

**TestFixture 설계 원칙**:
- 반복적인 테스트 설정을 메서드로 추출
- 여러 단계를 조합한 고수준 메서드 제공
- 테스트 가독성을 높이는 fluent API 스타일

### 4.2 커스텀 테스트 어노테이션

**@CommerceApiTest 정의**:
```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@SpringBootTest(
    classes = {
        CommerceApiApp.class,
        TestFixtureConfiguration.class,
        PasswordEncoderConfiguration.class,
    },
    webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT
)
public @interface CommerceApiTest {
}
```

**사용**:
```java
@CommerceApiTest
@DisplayName("POST /seller/signUp")
public class POST_specs {
    // 테스트 메서드들
}
```

**장점**:
- 테스트 설정 중복 제거
- 일관된 테스트 환경 보장
- 설정 변경 시 한 곳만 수정

### 4.3 TestDataSource 패턴

**중앙화된 테스트 데이터 관리**:
```java
public class TestDataSource {
    public static String[] invalidPasswords() {
        return new String[] {
            "",
            "pass",
            "pass123",
            "1234password",
            "password1234",
            "pass5678word"
        };
    }

    public static String[] invalidEmails() {
        return new String[] {
            null,
            "invalid-email",
            "invalid-email@",
            "invalid-email@test",
            "invalid-email@test.",
            "invalid-email@.com"
        };
    }
}
```

**사용 원칙**:
- 여러 테스트에서 재사용되는 데이터셋을 중앙화
- Parameterized 테스트의 `@MethodSource`와 함께 사용
- 정적 메서드로 제공

## 5. 테스트 데이터 생성 전략

### 5.1 Generator 패턴

**목적**: 유니크한 테스트 데이터 생성

**EmailGenerator 예시**:
```java
public class EmailGenerator {
    public static String generateEmail() {
        return UUID.randomUUID() + "@test.com";
    }
}
```

**사용**:
```java
// Arrange
var command = new CreateSellerCommand(
    generateEmail(),  // 매번 다른 이메일 생성
    generateUsername(),
    generatePassword(),
    generateEmail()
);
```

**Generator 작성 원칙**:
- UUID를 활용하여 유니크성 보장
- 간단한 정적 메서드로 제공
- 도메인별로 별도 Generator 클래스 작성

### 5.2 테스트 데이터 격리

**원칙**:
1. 각 테스트는 독립적인 데이터 사용
2. 테스트 간 데이터 공유 금지
3. 필요시 `deleteAll()` 등으로 초기화

**예시**:
```java
@Test
void 첫_번째_페이지의_상품을_반환한다(@Autowired TestFixture fixture) {
    // Arrange
    fixture.deleteAllProducts();  // 기존 데이터 정리

    fixture.createSellerThenSetAsDefaultUser();
    List<UUID> ids = fixture.registerProducts(PAGE_SIZE);
    // ...
}
```

## 6. 검증(Assertion) 패턴

### 6.1 AssertJ 사용

**기본 검증**:
```java
assertThat(response.getStatusCode().value()).isEqualTo(204);
assertThat(actual).isNotNull();
assertThat(actual.items()).extracting(ProductView::id).containsAll(ids);
```

**체이닝을 통한 복합 검증**:
```java
assertThat(requireNonNull(response.getBody()).items())
    .extracting(ProductView::id)
    .containsExactly(id3, id2, id1);
```

### 6.2 커스텀 Assertions

**ProductAssertions 예시**:
```java
public class ProductAssertions {
    public static ThrowingConsumer<SellerProductView> isDerivedFrom(
        RegisterProductCommand command
    ) {
        return product -> {
            assertThat(product.name()).isEqualTo(command.name());
            assertThat(product.imageUri()).isEqualTo(command.imageUri());
            assertThat(product.description()).isEqualTo(command.description());
            assertThat(product.priceAmount())
                .matches(equals(command.priceAmount()));
            assertThat(product.stockQuantity())
                .isEqualTo(command.stockQuantity());
        };
    }
}
```

**사용**:
```java
ProductView actual = requireNonNull(response.getBody()).items()[0];
assertThat(actual).satisfies(isViewDerivedFrom(command));
```

**커스텀 Assertions 작성 원칙**:
- 여러 필드를 함께 검증해야 할 때 사용
- `ThrowingConsumer` 패턴으로 AssertJ와 통합
- 도메인 의미를 담은 메서드명 사용 (예: `isDerivedFrom`)

## 7. Spring Boot 테스트 설정

### 7.1 테스트 구성 요소

**필수 의존성**:
- JUnit 5
- Spring Boot Test
- AssertJ
- TestRestTemplate

**테스트 타입**:
- 통합 테스트 중심 (API 레벨)
- `@SpringBootTest`로 전체 컨텍스트 로드
- `RANDOM_PORT`로 실제 HTTP 서버 구동

### 7.2 의존성 주입

**메서드 파라미터 주입**:
```java
@Test
void 테스트_시나리오(
    @Autowired TestRestTemplate client,
    @Autowired SellerRepository repository,
    @Autowired PasswordEncoder encoder
) {
    // 테스트 로직
}
```

**주입 가능한 주요 컴포넌트**:
- `TestRestTemplate client` - HTTP 요청 클라이언트
- `TestFixture fixture` - 테스트 헬퍼
- Repository - 데이터 검증용
- 기타 필요한 Bean

## 8. 테스트 작성 체크리스트

### 8.1 파일 생성 시

- [ ] API 경로에 맞는 패키지 구조 생성
- [ ] HTTP 메서드명_specs.java 형식으로 파일명 작성
- [ ] `@CommerceApiTest` 어노테이션 추가
- [ ] `@DisplayName`으로 API 엔드포인트 명시

### 8.2 테스트 메서드 작성 시

- [ ] 한글로 명확한 시나리오 작성
- [ ] Arrange-Act-Assert 구조 준수
- [ ] 주석으로 각 단계 명시
- [ ] 한 테스트에서 한 가지만 검증

### 8.3 테스트 시나리오 커버리지

- [ ] 성공 케이스
- [ ] 필수 속성 누락
- [ ] 속성 형식 검증
- [ ] 비즈니스 로직 검증
- [ ] 권한 검증 (해당 시)
- [ ] 페이지네이션 (해당 시)

### 8.4 코드 품질

- [ ] Generator로 테스트 데이터 생성
- [ ] TestFixture로 반복 코드 제거
- [ ] 커스텀 Assertions로 복잡한 검증 캡슐화
- [ ] Parameterized 테스트로 중복 제거
- [ ] 테스트 간 데이터 격리 보장

## 9. 예시: 새로운 API 테스트 작성

### 9.1 디렉토리 생성
```
src/test/java/test/commerce/api/order/create/
```

### 9.2 테스트 파일 생성
`POST_specs.java`

### 9.3 기본 구조 작성
```java
package test.commerce.api.order.create;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import test.commerce.api.CommerceApiTest;
import test.commerce.api.TestFixture;

import static org.assertj.core.api.Assertions.assertThat;

@CommerceApiTest
@DisplayName("POST /order/create")
public class POST_specs {

    @Test
    void 올바르게_요청하면_201_Created_상태코드를_반환한다(
        @Autowired TestFixture fixture
    ) {
        // Arrange
        fixture.createShopperThenSetAsDefaultUser();
        // ... 주문 데이터 준비

        // Act
        // ... API 호출

        // Assert
        // ... 응답 검증
    }

    @Test
    void 상품_ID가_지정되지_않으면_400_Bad_Request_상태코드를_반환한다(
        @Autowired TestFixture fixture
    ) {
        // Arrange
        // ...

        // Act
        // ...

        // Assert
        assertThat(response.getStatusCode().value()).isEqualTo(400);
    }

    // 추가 테스트 시나리오들...
}
```

## 10. 정리

이 가이드의 핵심 원칙:

1. **명확성**: 한글 메서드명으로 테스트 의도를 분명히 표현
2. **구조화**: API 경로를 반영한 일관된 패키지 구조
3. **재사용**: Generator, Assertions, TestFixture로 중복 제거
4. **격리**: 각 테스트는 독립적으로 실행 가능
5. **완전성**: 성공/실패 케이스, 유효성 검증, 비즈니스 로직 모두 커버

이 가이드를 따르면 일관되고 유지보수하기 쉬운 테스트 코드를 작성할 수 있습니다.
